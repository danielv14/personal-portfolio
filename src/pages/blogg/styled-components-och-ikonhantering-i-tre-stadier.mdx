---
title: 'Styled Components och ikonhantering i tre stadier'
summary: 'Hur m√•nga g√•nger kan man beh√∂va refaktorera ikoner egentligen? Minst tre g√•nger i alla fall - allt eftersom behovet p√• funktionalitet √§ndras.'
layout: blogPost
date: 2020-07-03
---

Denna sajt √§r byggt med hj√§lp av [Styled Components](https://styled-components.com/) och anv√§nder ikoner sparsamt, med hj√§lp av [styled-icons](https://styled-icons.js.org/) - ett paket som g√∂r det v√§ldigt enkelt kan skapa komponenter fr√•n svg-ikoner.

Totalt sett anv√§nds fyra ikoner p√• denna sajt i skrivande stund:
* Tv√• ikoner f√∂r m√∂rkt/ljust tema
* En ikon f√∂r Githubl√§nk
* En ikon f√∂r epostl√§nk

Det h√§r √§r en liten sammanfattning om hur ikonhanteringen √§ndrades i tre olika iterationer allt eftersom behovet av flera ikoner samt funktionalitet v√§xte och jag beh√∂vde standardisera ikonhanteringen p√• ett b√§ttre s√§tt.

## Skapa komponenter bara - hur sv√•rt ska det vara? ü§∑‚Äç‚ôÇÔ∏è

N√§r jag skapde den f√∂rsta ikonen var jag inte speciellt brydd om varken √•teranv√§ndbarhet eller potentiellt duplicerad kod. Jag beh√∂vde bara skapa n√•gra mindre ikonkomponenter f√∂r att visa upp ikoner i headern och footern.

I ett f√∂rsta stadie s√•g skapade jag ikoner p√• f√∂ljande s√§tt:

```tsx:src/components/ui/icons/iconDarkMode.tsx
import { Sunset } from '@styled-icons/feather';
import styled from 'styled-components';

export const IconDarkMode = styled(Sunset)`
  width: 24px;
  height: 24px;
  color: var(--text-muted-color);
`;

IconDarkMode.displayName = 'IconDarkMode';
```

Bra - nu hade jag en ikon som representerar "Dark mode" och som har lite generell styling. Men om man har en ikon f√∂r "Dark mode" s√• beh√∂vs ju en ikon f√∂r "Light mode" ocks√•:

```tsx:src/components/ui/icons/iconLightMode.tsx
import { Sunrise } from '@styled-icons/feather';
import styled from 'styled-components';

export const IconLightMode = styled(Sunrise)`
  width: 24px;
  height: 24px;
  color: var(--text-muted-color);
`;

IconLightMode.displayName = 'IconLightMode';
```

Perfekt - nu hade jag en ikon med samma styling men som representerar "Light mode".

**Men v√§nta lite nu...** B√§gge komponenterna `iconDarkMode.tsx` och `iconLightMode.tsx` ansvarar f√∂r en generell styling samt best√§mmer vilken ikon fr√•n styled-icons som ska anv√§ndas.
Det √§r inte speciellt skalbart om jag skulle beh√∂va √§ndra standard stylingen eller l√§gga till √§nnu fler ikoner - mer kod skulle dupliceras. N√•tt m√•ste man v√§l kunna g√∂ra √•t det problemet?

## Skapa en √•teranv√§ndbar default styling üë®‚Äçüé®

Problemet med duplicerad styling g√•r att l√∂sa p√• en rad olika s√§tt men i iteration tv√• av introducerade jag en separat k√§lla f√∂r standardstyling:

```tsx{9}:src/components/ui/icons/iconBase.ts
import styled, { css } from 'styled-components';

export interface IconProps {
  hoverEffect?: boolean;
}

const HoverStyle = css`
  transition: all 0.2s ease;
  &:hover {
    transform: translateY(-2px);
  }
`;

export const BaseStyle = ({ hoverEffect = false }: IconProps) => css`
  width: 24px;
  height: 24px;
  color: var(--text-muted-color);
  `${hoverEffect ? HoverStyle : ''}`
`;

export const IconBase = styled.svg<IconProps>`
  ${BaseStyle}
`;
```

**iconBase.ts** inneh√•ller i den h√§r iterationen all grundl√§ggande styling som alla ikoner anv√§nde sig av och hade ett gemensamt interface f√∂r ikonprops. En hover-effekt lades √§ven till.

Ikoner i sin tur byggdes ovanp√• **iconBase.ts** p√• f√∂ljande vis:

```tsx:src/components/ui/icons/iconLightMode.tsx

import { Sunrise } from '@styled-icons/feather';
import styled from 'styled-components';
import { BaseStyle, IconProps } from './iconBase';

export const IconLightMode = styled(Sunrise)<IconProps>`
  ${BaseStyle}
`;

IconLightMode.displayName = 'IconLightMode';
```

**Perfekt!** Nu var duplicerad kod borttagen och endast en k√§lla till ikonstyling existerade. Nu m√•ste v√§l allt vara frid och fr√∂jd?

## Skapa komponenter med (ett) tydligt ansvar üôã‚Äç‚ôÇÔ∏è 

Det var √§nd√• n√•got som inte k√§ndes helt r√§tt. Alla ikoner som bygger vidare p√• **iconBase.ts** ansvarar inte ***bara*** f√∂r vilken svg-ikon de importerar och anv√§nder sig av. De ansvarar ***√§ven*** f√∂r att se till att ikonerna applicerar den grundl√§ggande stylingen fr√•n **iconBase.ts**. 

Vore det inte b√§ttre om om alla olika ikonkomponenter ist√§llet ***bara*** ansvarade f√∂r vilken ikon fr√•n styled-icons de importerade och skickade vidare allt annat ansvar s√•som *props* och *styling* till **iconBase.ts**?

S√• klart det vore! I iteration tre och nuvarande version (i skrivande stund) separerades det ansvaret genom en mindre refaktorering av **iconBase.ts**:

```tsx{4,14,15,16}:src/components/ui/icons/iconBase.ts
import styled, { css } from 'styled-components';
import { StyledIconProps, StyledIcon } from '@styled-icons/styled-icon';

export interface IconProps extends StyledIconProps {
  hoverEffect?: boolean;
}

const HoverStyle = css`
  transition: all 0.2s ease;
  &:hover {
    transform: translateY(-2px);
  }
`;

const defaultSize = css`
  height: 24px;
  width: 24px;
`;

export const BaseStyle = ({ hoverEffect = false, size }: IconProps) => css`
  color: var(--text-muted-color);
  `${!size && defaultSize}`;
  `${hoverEffect && HoverStyle}`;
`;

export const IconBase = (icon: StyledIcon): StyledIcon => styled(icon)<IconProps>`
  ${BaseStyle}
`;

```

> `${!size && defaultSize}` anv√§nds f√∂r att styled-icons har en prop, size, som s√§tter en storlek p√• ikonerna. Om ingen storlek s√§tts s√• faller basikonen till en defaultstorlek.

N√•gra sm√• √§ndringar (som √§r markerade i kodsnutten ovan) visar p√• skillnaderna. Interfacet `IconProps` bygger nu vidare p√• interfacet `StyledIconProps` - som √§r det interface som alla styled-icons har.

`IconBase` var tidigare bara en `styled.svg` som hade lite grundl√§ggande styling i och med `BaseStyle`. Nu √§r det en funktion som tar in en `icon` av typen `StyledIcon` och returnerar en styled-icon som har default styling och som har korrekt interface f√∂r props.

Ikonkomponenter refaktorerades i iteration tre att se ut p√• f√∂ljande vis:

```tsx:src/components/ui/icons/iconLightMode.tsx
import { Sunrise } from '@styled-icons/feather';
import { IconBase, IconProps } from './iconBase';

const Icon = IconBase(Sunrise);

export const IconLightMode: React.FC<IconProps> = (props) => {
  return <Icon {...props} />;
};

IconLightMode.displayName = 'IconLightMode';

```

Nu har de egentligen bara **ett enda ansvar** - att best√§mma vilken ikon de ska importera och representera i och med `const Icon = IconBase(Sunrise);
`. Ikonkomponenterna skickar glatt vidare alla props med spread `return <Icon {...props} />;` och all styling och √∂vrig logik hanteras i baskomponenten ist√§llet.

## Summering

S√• l√§nge man f√∂rs√∂ker t√§nka p√• att separera ansvar och har √•teranv√§ndbarhet i √•tanke kan man skapa r√§tt s√• flexibla l√∂sningar f√∂r ui-komponenter, med hj√§lp av styled components.

Att l√•ta en komponent p√• en "l√§gre" niv√• ansvara f√∂r gemensam logik och generella stilregler g√∂r att man kan skapa komponenter "ovanp√•" - som inte beh√∂ver bry sig, eller ens veta om de gemensamma detaljerna.

Det √§r inte hela v√§rlden om det inte blir 100% r√§tt f√∂rsta g√•ngen eller om koden man skriver i en f√∂rsta implementation √§r 100% DRY alla g√•nger.
Det kan dessutom vara sv√•rt att p√• f√∂rhand se hela behovsbilden och det √§r l√§tt att b√∂rja optimera f√∂r fel saker om man f√∂rs√∂ker t√§cka in f√∂r mycket - f√∂r tidigt.

√ñver tid n√§r behoven √§ndras och man v√§xer ur befintlig implementation √§r det bara att iterera och refaktorera i mindre steg tills man uppn√•r ett b√§ttre l√§ge och t√§cker in nyuppt√§ckta behov.



