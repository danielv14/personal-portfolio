---
title: NÃ¤r man fÃ¶rmodligen vill byta ut useState mot useReducer
summary: useState Ã¤r bra till mycket. Men ibland rÃ¤cker inte useState hela vÃ¤gen. Det hÃ¤r Ã¤r lite reflektioner Ã¶ver fÃ¶rsta gÃ¥ngen jag anvÃ¤nde useReducer fÃ¶r att lÃ¶sa lite mer avancerad state.
layout: blogPost
date: 2021-02-13
---

Det hÃ¤r Ã¤r en genomgÃ¥ng och reflektioner av hur det gick till nÃ¤r jag fÃ¶r fÃ¶rsta gÃ¥ngen anvÃ¤nde useReducer som ett rimligare alternativ till useState, pÃ¥ grund av ett multi-steg-formulÃ¤rs komplexitet.

## Kort om useState

React-hook:en `useState` Ã¤r vÃ¤ldigt smidig att anvÃ¤nda nÃ¤r man vill gÃ¶ra en funktionskomponent stateful. Det Ã¤r relativt lÃ¤tt att hÃ¤mta lite data asynkront frÃ¥n ett API och sÃ¤tta det i state, eller koppla ihop inputfÃ¤ltvÃ¤rden med state.

En uppenbar skillnad mellan useState och hur man ofta skriver och sÃ¤tter state i klasskomponenter Ã¤r att man via useState kan ha flera â€state-variablerâ€, medan man i en klass-komponent jobbar med state som ett objekt.

SÃ¤g att man har ett formulÃ¤r och vill anvÃ¤nda useState fÃ¶r state-hantering med 3-4 inputfÃ¤lt. Det enklaste Ã¤r nog att ha separata state-variabler fÃ¶r varje inputfÃ¤lt, ungefÃ¤r sÃ¥ hÃ¤r:

```js
const [inputOne, setInputOne] = useState(â€™â€™);
const [inputTwo, setInputTwo] = useState(â€™â€™);
const [inputThree, setInputThree] = useState(â€™â€™);
const [inputFour, setInputFour] = useState(â€™â€™);
```

Att separera state fÃ¶r ett formulÃ¤r pÃ¥ det hÃ¤r sÃ¤ttet kanske Ã¤r det mest uppenbara tillvÃ¤gagÃ¥ngssÃ¤ttet. Ett alternativ fÃ¶r nÃ¤r ett formulÃ¤r, eller vilken sorts komponent som helst egentligen som behÃ¶ver state, inte Ã¤r speciellt komplext och nÃ¤r det inte finns sÃ¥ mÃ¥nga â€nyanserâ€ i hur state:t kan se ut.

NÃ¤r man dÃ¥ istÃ¤llet behÃ¶ver lite komplexare state-hantering kan det kanske ses naturligt att gruppera state i ett objekt istÃ¤llet, likt state fÃ¶r en klass-komponent. Detta kan framfÃ¶r allt vara bra fÃ¶r att man fÃ¥r en bÃ¤ttre Ã¶verblick Ã¶ver hur en komponents state ser ut, istÃ¤llet fÃ¶r att man har vÃ¤ldigt mÃ¥nga individuella `const [state, setState] = useState()` att hÃ¥lla reda pÃ¥.

Ã–verskÃ¥dligheten blir om Ã¤nnu bÃ¤ttre om man anvÃ¤nder TypeScript och kan typa upp sitt useState objekt.

### NÃ¤r useState inte rÃ¤cker till

RÃ¤cker det dÃ¥ att fortsÃ¤tta anvÃ¤nda useState tillsammans med ett objekt istÃ¤llet och lÃ¥ta formulÃ¤ret/funktionskomponent skÃ¶ta lite komplexare state-logik? Inte riktigt. Den officiella dokumentationen fÃ¶r React [rekommenderar](https://reactjs.org/docs/hooks-reference.html) att man istÃ¤llet ska anvÃ¤nda hook:en `useReducer`, med motiveringen:

> **useReducer** is usually preferable to **useState** when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one

Flera individuella useState-variabler, ett enda state-objekt och sen useReducer. Det Ã¤r i stora drag de tre olika stadier som jag och en kollega gick igenom nÃ¤r vi fÃ¶r ett tag sedan i ett projekt skulle bygga ett multi-stegs formulÃ¤r. Ett formulÃ¤r som involverade datahÃ¤mtning via ett API och dÃ¤r de olika formulÃ¤r-stegen hade beroenden av state mellan sig.

## Fas 1: useState-variabler everywhere!

Jag och en kollega skulle som sagt bygga ett formulÃ¤r som hade flera olika steg. Kortfattad och simplifierat skulle formulÃ¤ret bete sig sÃ¥ hÃ¤r:

- **I steg 1:** InputfÃ¤lt fÃ¶r att sÃ¶ka efter data via ett API och lÃ¥t anvÃ¤ndaren vÃ¤lja ett alternativ frÃ¥n API:et. Beroende pÃ¥ vad anvÃ¤ndaren vÃ¤ljer gÃ¥r ett till API-anrop ivÃ¤g och beroende pÃ¥ om man fÃ¥r en eller fler trÃ¤ffar tillbaka lÃ¥t anvÃ¤ndaren vÃ¤lja ett av de alternativen. FÃ¥r man bara en trÃ¤ff frÃ¥n det andra API-anropet ska den infon sÃ¤ttas direkt i state istÃ¤llet fÃ¶r att anvÃ¤ndaren behÃ¶ver vÃ¤lja nÃ¥got.
- **I steg 2**: Beroende pÃ¥ state som sÃ¤tts i steg 1 sÃ¥ hÃ¤mtas annan data frÃ¥n ett API och anvÃ¤ndaren fÃ¥r vÃ¤lja nÃ¥gra alternativ i dropdown-inputs.
- **I steg 3**: AnvÃ¤ndaren granskar den data som hen angett i steg 1 och 2.

AnvÃ¤ndaren har Ã¤ven mÃ¶jlighet att backa ett steg i taget i formulÃ¤ret och eftersom att steg 2 beror pÃ¥ data som valts i steg 1 sÃ¥ skulle all state rensas i steg 1.

NÃ¤r vi bÃ¶rjade bygga formulÃ¤ret hade vi inte riktigt rett ut exakt alla stadier och nyanser i state:et fÃ¶r formulÃ¤ret.

Vi bÃ¶rjade helt enkelt med en `const [inputOne, setInputTwo] = useState(â€™â€™)` fÃ¶r varje liten del av formulÃ¤r-state:t vi kom pÃ¥ och byggde successivt upp mer och mer state-variabler och kopplade ihop dessa med `onChange()` callbacks pÃ¥ input-fÃ¤lt och satte data frÃ¥n API-anrop till state-variablerna.

I takt med att vi utforskade all state-logik och komplexitet som faktiskt fanns i det formulÃ¤r vi hÃ¶ll pÃ¥ att bygga insÃ¥g vi att det vart rÃ¤tt ohÃ¥llbart att hÃ¥lla reda pÃ¥ all state-logik. Detta fÃ¶r att smÃ¥ bitar av formulÃ¤r-state sattes hÃ¤r och dÃ¤r i callbacks och asynkront efter API-anrop.

Vi bÃ¶rjade Ã¤ven fÃ¥ state-variabler som berodde pÃ¥ andra state-variabler och hade svÃ¥rt att se helheten fÃ¶r formulÃ¤ret, all dess logik och nyanser av state.

## Fas 2: Gruppera state i ett objekt

I ett fÃ¶rsÃ¶k att ta lite mer kontroll Ã¶ver formulÃ¤rets state och fÃ¥ bÃ¤ttre Ã¶verblick sÃ¥ flyttade vi in alla individuella bitar av state till ett enda objekt istÃ¤llet.

Att gruppera allt i ett objekt hjÃ¤lpte till avsevÃ¤rt med Ã¶verblicken av formulÃ¤r-datat. Mycket fÃ¶r att vi skrev TypeScript-kod och typade upp ett interface fÃ¶r hela formulÃ¤rets state.

Vi slapp Ã¤ven flera individuella `setState()` anrop fÃ¶r flera sub-vÃ¤rden i state:t. Vi gick frÃ¥n sÃ¥nt hÃ¤r:

```js
const onInputChange = async (value) => {
  setInputOne(value);
  const data = await fetchFromAPI(value);
  setDataOne(data);
};
```

Till att istÃ¤llet skriva sÃ¥nt hÃ¤r:

```js
const onInputChange = async (value) => {
  const data = await fetchFromAPI(value);
  setState({ ...state, inputOne: value, dataOne: data });
};
```

Perfekt. Vi hade nu alltsÃ¥ bÃ¤ttre koll pÃ¥ hur formulÃ¤rets state sÃ¥g ut fÃ¶r att allt var grupperat.

NÃ¥got vi fortfarande hade problem med var att vi i **formulÃ¤r-komponenten behÃ¶vde ha stenkoll pÃ¥ beroenden mellan sub-vÃ¤rden i state-objektet**.

Ett konkret exempel pÃ¥ detta Ã¤r att vi allt eftersom upptÃ¤ckte att vi behÃ¶vde lite custom input-valideringsfeedback i formulÃ¤rets olika steg innan man kunde gÃ¥ vidare till nÃ¤sta steg. SÃ¥n feedback ritades ut i alerts direkt i formulÃ¤ret och feedback-texterna sattes i state-objektet som en array med strÃ¤ngar.

Om anvÃ¤ndaren dÃ¥ fÃ¶rsÃ¶kte gÃ¥ vidare till nÃ¤sta steg i formulÃ¤ret fick denne feedback om att viss input-data saknades. NÃ¤r anvÃ¤ndaren dÃ¥ bÃ¶rjade fylla i den datan skulle feedbacken fÃ¶rsvinna. Vi bÃ¶rjade fÃ¥ sÃ¥dana hÃ¤r exempel lite hÃ¤r och var i koden:

```js
const onInputChange = (value) => {
  setState({ ...state, inputOne: value, feedback: [] });
};
```

Ett annat exempel pÃ¥ beroenden mellan sub-vÃ¤rden Ã¤r att det kunde uppstÃ¥ scenarion dÃ¥ anvÃ¤ndaren inte ens skulle kunna gÃ¥ vidare frÃ¥n steg 1 till steg 2, beroende pÃ¥ den data man fick tillbaka frÃ¥n API:et i steg 1. Detta styrde vi med boolean-flaggor i state-objektet som sattes till true eller false beroende pÃ¥ svarsdatat frÃ¥n API:et.

Ett tredje exempel Ã¤r att all state skulle rensas nÃ¤r anvÃ¤ndarn gick tillbaka till steg 1 i formulÃ¤ret. Vi hade en generell funktion som tog in ett givet steg som en parameter och satte den parametern i state-objektet. NÃ¤r inparametern dock var `0`, vilket representerade steg 1, sÃ¥ skulle hela state:t tÃ¶mmas.

Komplexiteten och alla nyanser i state:t behÃ¶vde dels vi som utvecklare av formulÃ¤ret, men Ã¤ven formulÃ¤ret i sig ha stenkoll pÃ¥. I en del lÃ¤gen skulle man sÃ¤tta men ocksÃ¥ rensa sub-vÃ¤rden i state:t och i andra lÃ¤gen skulle man tolka data som skulle sÃ¤ttas i tvÃ¥ sub-state vÃ¤rden pÃ¥ tvÃ¥ olika sÃ¤tt.

**Det Ã¤r i det hÃ¤r lÃ¤get som vi bÃ¶rjade snegla pÃ¥ att anvÃ¤nda useReducer istÃ¤llet.**

## Fas 3: Kasta ut useState och vÃ¤lkomna useReducer

Den korta beskrivningen en bit upp i denna text som beskriver de lÃ¤gen som useReducer Ã¤r att rekommendera Ã¶ver useState angÃ¥ende komplex state-logik och sub-vÃ¤rden Ã¤r vÃ¤ldigt talande fÃ¶r de fÃ¶rdelar vi snabbt sÃ¥g efter att vi hade refaktorerat formulÃ¤rets state till en useReducer istÃ¤llet.

Att vi bÃ¶rjade snegla mot useReducer bÃ¶rjade vÃ¤l med att vi i princip hade all state-logik pÃ¥ plats och formulÃ¤ret i sin helhet fungerade enligt kravspec, med vÃ¥rat state-objekt.

Men nÃ¤r vi kikade igenom koden kÃ¤ndes det fortfarande som att det var vÃ¤ldigt mÃ¥nga olika callbacks osv dÃ¤r state sattes och vi hade fortfarande kvar alla beroenden mellan sub-vÃ¤rden.

FormulÃ¤r-komponenten var helt enkelt svÃ¥r att hÃ¤nga med i dÃ¥ det sattes state lite hÃ¤r och dÃ¤r och vi behÃ¶vde ha stenkoll pÃ¥ i vilka callbacks som validerings-feedback skulle rensas osv.

FormulÃ¤ret i sig behÃ¶vde Ã¤ven ha koll pÃ¥ att nÃ¤r anvÃ¤ndaren klickar sig bakÃ¥t mellan stegen sÃ¥ ska hela state-objektet rensas om anvÃ¤ndaren klickade sig tillbaka till fÃ¶rsta steget.

### Vad gÃ¶r useReducer?

Vad Ã¤r det dÃ¥ som skiljer useState frÃ¥n useReducer? useReducer fungerar lite mer som Redux i det sÃ¤tt att useReducer-hooken ger tillbaka `state` och en `dispatch` funktion. Via dispatch skickar man olika â€actionsâ€ med eller utan data fÃ¶r att uppdatera state, via en reducer-funktion:

```js
const [state, dispatch] = useReducer(reducer, initialState);
```

Reducer-funktionen i sin tur tar state:ta nuvarande version och en action som parametrar och vanligtvis (precis som med Redux) sÃ¥ brukar reducern bestÃ¥ av en switch/case pÃ¥ `action.type` dÃ¤r olika action-types uppdaterar state pÃ¥ lite olika sÃ¤tt.

> Vill man veta mer om useReducer sÃ¥ Ã¤r den [officiella dokumentationen](https://reactjs.org/docs/hooks-reference.html) en bra startpunkt.

FÃ¶r den komponent som ska uppdatera state handlar det fÃ¶renklat om att man gÃ¥r frÃ¥n `setState({ ...state, inputOne: value})` till `dispatch({ type: â€™INPUT_ONEâ€™, value })`.

### Vilka fÃ¶rdelar sÃ¥g vi?

Vilka fÃ¶rdelar kunde vi dÃ¥ se nÃ¤r vi refaktorerade frÃ¥n lÃ¶sningen med useState och vÃ¥rat state-objekt till att anvÃ¤nda useReducer istÃ¤llet?

Den allra stÃ¶rsta fÃ¶rdelen vi sÃ¥g var att formulÃ¤r-komponenten nu bara behÃ¶vde fokusera pÃ¥ **vad** som skulle hÃ¤nda och inte exakt **hur** nÃ¥got skulle hÃ¤nda. Om man ska ta exemplet med att lÃ¥ta anvÃ¤ndaren backa i formulÃ¤ret sÃ¥ gick vi frÃ¥n (ungefÃ¤r):

```js
const onStepChange = (step) => {
  if (step === 0) {
    setState(emptyFormData);
    return;
  }
  setState({ ...state, step: step });
};
```

Till en lÃ¶sning dÃ¤r formulÃ¤ret inte behÃ¶vde bry sig om sÃ¥dana detaljer:

```js
const onStepChange = (step) => {
	dispatch({ type: â€™FORM_STEPâ€™, step: step });
}
```

VÃ¥r formulÃ¤r-reducer sÃ¥g dÃ¥ till att sjÃ¤lv antingen bara back ett steg eller rensa hela formulÃ¤ret.

En annan fÃ¶rdel vi sÃ¥g var att formulÃ¤ret inte lÃ¤ngre behÃ¶vde bry sig om att i vissa lÃ¤gen rensa den validerings-feedback array som fanns i state. SÃ¥dana detaljer var upp till reducern att skÃ¶ta, beroende pÃ¥ vilken action som formulÃ¤ret dispatchade.

En tredje fÃ¶rdel var att formulÃ¤ret nu inte lÃ¤ngre behÃ¶vde bry sig alls om eventuella beroenden mellan sub-vÃ¤rden i state:t. FormulÃ¤ret dispatchade bara sina actions med tillhÃ¶rande data och reducern sÃ¥g till att sÃ¤tta eventuella boolean-flaggor osv sjÃ¤lv.

Visserligen innebar useReducern lite mer â€boilerplate-kodâ€, framfÃ¶r allt dÃ¥ vi jobbar med TypeScript och typade upp alla action-typen och payloads som man kunde skicka in i reducern. Men detta innebar ju ocksÃ¥ att vi fick ett tydligare kontrakt mellan formulÃ¤ret och reducern och hur kommunikationen dÃ¤r emellan sÃ¥g ut.

DÃ¥ vi lyfte ut useReducern till en custom hook blev dessutom formulÃ¤r-komponenten 100% mer Ã¶verskÃ¥dlig. Detta dÃ¥ den i princip bara hÃ¤mtade data frÃ¥n API:er i vissa funktioner och dispatchade actions, samt dispatchade vissa actions direkt i â€onInputChange-funktionerâ€.

All faktiskt state-hantering lyftes ut till en separat fil och behÃ¶vde vi se hur state:t i detalj skulle fÃ¶rÃ¤ndras Ã¶ver tid gav reducern oss en tydligare Ã¶verblick, istÃ¤llet fÃ¶r att behÃ¶va skrolla runt i formulÃ¤r-komponenten och jaga `setState` anrop.

## Summering

Phew! DÃ¤r var vi i mÃ¥l!

Vad kan man dÃ¥ dra fÃ¶r summerande slutsatser av det hela? Ska man strunta i useState helt och istÃ¤llet anvÃ¤nda useReducer? Absolut inte! Hook:en useState Ã¤r vÃ¤ldigt bra om man har ett state som inte Ã¤r speciellt komplext. Att alltid anvÃ¤nda useReducer skulle fÃ¶rmodligen innebÃ¤ra onÃ¶digt komplex lÃ¶sning fÃ¶r en icke-komplex utmaning.

Men Ã¥ andra sidan tror jag inte man ska vara rÃ¤dd fÃ¶r att byta ut useState mot useReducer i de lÃ¤gen en komponents state vÃ¤xer. Personligen tyckte jag att useReducer sÃ¥g ut som onÃ¶digt avancerat sÃ¤tt att hantera state i funktions-komponenter innan jag testade pÃ¥ den, men sÃ¥g genast fÃ¶rdelar med den nÃ¤r jag vÃ¤l bÃ¶rjade anvÃ¤nda den.

Har man lite mer avancerat state och synkar inte bara input-fÃ¤lt till data eller tÃ¤nder och slÃ¤cker grejer rent visuellt med boolean-flaggor Ã¤r useReducer ett vÃ¤ldigt bra alternativ fÃ¶r att fÃ¥ bÃ¤ttre kontroll Ã¶ver state och state-fÃ¶rÃ¤ndringar.

> VÃ¤rt att pÃ¥peka Ã¤r ju att det hÃ¤r Ã¤r tankar och funderingar efter att ha anvÃ¤nt useReducer en gÃ¥ng ğŸ˜† Men jag kÃ¤nde Ã¤ndÃ¥ fÃ¶r att fÃ¥ nedskrivet nÃ¥gra reflektioner.

NÃ¤sta gÃ¥ng jag stÃ¥r infÃ¶r lite mer avancerad state kommer jag i alla fall inte tveka att Ã¶vervÃ¤ga useReducer som lÃ¶sning istÃ¤llet fÃ¶r useState, dÃ¥ man har mycket att vinna pÃ¥ det!
