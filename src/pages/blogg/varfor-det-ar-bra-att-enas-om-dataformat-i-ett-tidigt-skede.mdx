---
title: Varf√∂r det √§r bra att enas om dataformat i ett tidigt skede
summary: Dataformat kan m√•nga g√•nger hj√§lpa till att f√∂rhindra blockers och l√∂sa upp beroenden. Att enas om dataformat kan inneb√§ra att man kan jobba mot samma sprintm√•l, fr√•n flera olika h√•ll samtidigt.
layout: blogPost
date: 2020-10-07
---

## Sprintar med blockers och beroenden

Att arbeta effektivt inom projekt och sprintar kan ibland vara sv√•rt. Framf√∂rallt om ett projektet inneh√•ller olika moment eller jira-tickets som egentligen beror p√• tidigare moment eller andra jira-tickets, under en och samma sprint.

Det g√§ller att jobba smart f√∂r att f√∂rhindra blockers och l√∂sa upp beroenden under sprinten.

## Ett tydligt dataformat kan hj√§lpa

**Hur jobbar man d√• egentligen smart f√∂r att f√∂rhindra blockers och l√∂ser upp beroenden?**

Det finns s√• klart en uppsj√∂ olika smarta knep och arbetss√§tt att ta till sig. Men jag t√§nkte lyfta fram en grej som hj√§lpt mig mycket i tv√• projektsprintar under denna h√∂st och det √§r vikten av att **enas om ett dataformat** tidigt i sprinten.

Det h√§r √§r s√• klart inte applicerbart i _alla_ sprintar eller n√•got som l√∂ser upp _alla_ beroenden. Men det √§r n√•got som m√•nga g√•nger kan till√•ta samtidigt arbete mot ett gemensamt sprintm√•l fr√•n flera utvecklare - fr√•n olika h√•ll.

Men p√• vilket s√§tt hj√§lper detta en sprint och hur f√∂r det med sig effektivare arbete genom att man enas om ett dataformat? Jo... jag t√§nkte ge tv√• stycken exempel, baserade p√• de tv√• projektsprintarna jag n√§mnde tidigare.

> De exempel jag t√§nkte ta upp √§r bara l√∂st baserade p√• de uppgifter och m√•l som de faktiska sprintarna innebar. Jag beskriver bara uppgifterna l√∂st d√• det √§r inte uppgifterna i sig som driver po√§ngen.

## Exempel fr√•n en sprint üèÉ‚Äç‚ôÇÔ∏è

I f√∂rsta sprinten, som f√∂r √∂vrigt varade tv√• veckor, hade jag och en till kollega i uppgift att bland annat (f√∂renklat):

- Parsa xml-data som kommer fr√•n en RabbitMQ exchange till ett nytt json-format.
- Ta emot ovanst√•ende json payload i en Node-server och utf√∂r en uppgift.

Snabbt m√§rker man ju att den sista punkten har ett beroende p√• den f√∂rsta punkten, eftersom parsningen av xml-datan till json skulle ske med hj√§lp av ett npm-paket som servern skulle anv√§nda.

### Spika dataformat tidigt

F√∂r att vi skulle kunna arbeta effektivt spikade vi _hur_ json-datan skulle se ut. I och med detta s√• kunde vi jobba fr√•n tv√• olika h√•ll.
En av oss kunde jobba med npm-paketet f√∂r att se till att paketet kunde parsa xml-data till det f√∂rv√§ntade json-objektet och den andra (jag) jobbade i servern.

### Bygga funktionalitet kring mockat data

Att vi hade best√§mt oss f√∂r ett dataformat p√• json-objektet innebar att jag kunde mocka f√∂rv√§ntad data tillsvidare och bygga funktionaliteten som beh√∂vdes runt det.

### Skriva tester

Jag kunde skriva enhetstester som gick igenom med mock-data p√• plats och jag kunde √§ven skriva enhetstester som _inte_ gick igenom f√∂rr√§n d√• jag kunde byta ut mock-datat. D√• gick slutligen alla tester igenom och jag var, i och med testerna, mer trygg med att bytet till riktig data inte drog med sig buggar eller icke-f√∂rv√§ntat beteende i servern.

### Kringg√• blockers och genomf√∂ra i princip en hel uppgift

Ist√§llet f√∂r att vara helt blockad med min ticket kunde jag jag genomf√∂ra 90% av ticketen parallellt med arbetet med parsningen, p√• grund av att vi hade spikat ett gemensamt dataformat.

> **Andra f√∂rdelar:** Ytterligare en f√∂rdel med att arbeta utifr√•n samma dataformat fr√•n olika h√•ll tidigt i sprinten √§r att man mer ordentligt testar dataformatet och kan ‚Äùk√§nna sig f√∂r‚Äù p√• ett b√§ttre s√§tt. √Ñr dataformatet rimligt? G√•r det att anv√§nda p√• det s√§tt vi t√§nkt oss? S√•dana fr√•gor f√•r man snabbare svar p√•.

## Exempel fr√•n en andra sprint üèÉ‚Äç‚ôÇÔ∏è

I andra sprinten, som ocks√• varade i tv√• veckor, hade jag och en till kollega i uppgift att bland annat (f√∂renklat):

- Skapa en REST-endpoint som h√§mta en lista med objekt.
- Anropa endpointen fr√•n en React frontend och rita ut listan med objekten med React komponenter.

√Ñven i det h√§r fallet m√§rker man snabbt att den andra punkten har ett beroende p√• den f√∂rsta och √§ven h√§r inser man att ett spikat gemensamt dataformat inneb√§r att man kan arbeta mot samma sprintm√•l fr√•n olika h√•ll.

### Mocka data f√∂r utritning i frontend

Utifr√•n dataformatet som REST-endpointen skulle leverera kunde vi arbeta i mot sprintm√•let fr√•n olika h√•ll parallellt. I mitt fall handlade det om att mocka datat i React frontend:en och rita ut mock-datat med React komponenter.

### Att enkelt g√• fr√•n mock data till riktig datak√§lla

N√§r endpointen sen var p√• plats handlade det bara f√∂r min del om att byta ut datak√§llan i en container-komponent i frontend:en fr√•n h√•rdkodad mock-data till att anropa endpointen.

> üëÜ Precis som med allt annat s√• vill man separera ansvar f√∂r React komponenter. Ett vanligt m√∂nster √§r att man har _container-komponenter_ som ansvarar f√∂r att h√§mta data fr√•n datak√§llor och s√• har man _presentation-komponenter_ som sk√∂ter sj√§lva utritningen.
>
> Tanken √§r d√• att containern h√§mtar datan och ger datan som `props` till presentationskomponenten f√∂r utritning.

### Kringg√• blockers

√Öterigen gjorde det gemensamma dataformatet att jag kunde jobba p√• en annars blockad ticket till 90% f√§rdig innan de sista 10% gjordes, genom att anropa den faktiska endpointen.

## Get to the po√§ng

Vad √§r det jag vill f√• sagt egentligen? ü§î Jo... n√§mligen att man m√•nga g√•nger kan kringg√• blockers i projekt/sprintar genom att enas om det dataformat som d√• och d√• genomsyrar ett helt projekt eller en hel sprint.

Ett dataformat kan ses som ett kontrakt mellan exempelvis en front- och backend. Att i ett tidigt stadie best√§mma hur detta dataformat, eller kontrakt, ska se ut inneb√§r att man kan jobba mer effektivt, h√•lla antalet blockers nere och mjuka upp beroenden och helt enkelt jobba mer effektivt.
