---
title: 'Styled Components och ikonhantering i olika stadier'
summary: 'Hur m√•nga g√•nger kan man beh√∂va refaktorera ikoner egentligen? Minst tv√• g√•nger i alla fall - allt eftersom behovet p√• funktionalitet √§ndras.'
layout: blogPost
date: 2020-07-03
---

Denna sajt √§r byggt med hj√§lp av [Styled Components](https://styled-components.com/) och anv√§nder ikoner sparsamt, med hj√§lp av [styled-icons](https://styled-icons.js.org/) - ett paket som g√∂r det v√§ldigt enkelt kan skapa komponenter fr√•n svg-ikoner.

Totalt sett anv√§nds fyra ikoner p√• denna sajt i skrivande stund:

- Tv√• ikoner f√∂r m√∂rkt/ljust tema
- En ikon f√∂r Githubl√§nk
- En ikon f√∂r epostl√§nk

Det h√§r √§r en liten sammanfattning om hur ikonhanteringen √§ndrades i tre olika iterationer allt eftersom behovet av funktionalitet och fler ikoner v√§xte. Jag beh√∂vde standardisera ikonhanteringen p√• ett b√§ttre s√§tt.

> Jag g√•r h√§r inte in i detalj igenom hur styled-components samt styled-icons fungerar utan jag anv√§nder mer de tv√• f√∂r att visa ett exempel p√• hur man kan strukturera ui-komponenter med React och tar upp n√•gra saker att t√§nka p√•.

## Skapa komponenter bara - hur sv√•rt ska det vara? ü§∑‚Äç‚ôÇÔ∏è

N√§r jag skapde den f√∂rsta ikonen var jag inte speciellt brydd om varken √•teranv√§ndbarhet eller potentiellt duplicerad kod. Jag beh√∂vde bara skapa n√•gra mindre ikonkomponenter f√∂r att visa upp ikoner i headern och footern.

I ett f√∂rsta stadie skapade jag ikoner p√• f√∂ljande s√§tt:

```tsx:src/components/ui/icons/iconDarkMode.tsx
import { Sunset } from '@styled-icons/feather';
import styled from 'styled-components';

export const IconDarkMode = styled(Sunset)`
  width: 24px;
  height: 24px;
  color: var(--text-muted-color);
`;

IconDarkMode.displayName = 'IconDarkMode';
```

Bra - nu hade jag en ikon som representerar "Dark mode" och som har lite generell styling. Men om man har en ikon f√∂r "Dark mode" s√• beh√∂vs ju en ikon f√∂r "Light mode" ocks√•:

```tsx:src/components/ui/icons/iconLightMode.tsx
import { Sunrise } from '@styled-icons/feather';
import styled from 'styled-components';

export const IconLightMode = styled(Sunrise)`
  width: 24px;
  height: 24px;
  color: var(--text-muted-color);
`;

IconLightMode.displayName = 'IconLightMode';
```

Perfekt - nu hade jag en ikon med samma styling men som representerar "Light mode".

**Men v√§nta lite nu...** B√§gge komponenterna `iconDarkMode.tsx` och `iconLightMode.tsx` ansvarar f√∂r en generell styling samt best√§mmer vilken ikon fr√•n styled-icons som ska anv√§ndas.
Det √§r inte speciellt skalbart ifall jag beh√∂ver **√§ndra standard stylingen** eller **l√§gga till √§nnu fler ikoner** - mer kod skulle dupliceras. N√•tt m√•ste man v√§l kunna g√∂ra √•t det problemet?

## Skapa en √•teranv√§ndbar default styling üë®‚Äçüé®

Som med s√• mycket annat ville jag l√§gga till ny funktionalitet. Ikonerna skulle ha en liten effekt med `transform: translateY(2px)` n√§r man skulle klicka p√• dom.
Jag beh√∂vde r√•da bot p√• den duplicerade stylingen.

Problemet med duplicerad styling g√•r att l√∂sa p√• en rad olika s√§tt men i iteration tv√• av introducerade jag en separat k√§lla f√∂r standardstyling:

```tsx{9}:src/components/ui/icons/iconBase.ts
import styled, { css } from 'styled-components';

export interface IconProps {
  hoverEffect?: boolean;
}

const HoverStyle = css`
  transition: all 0.2s ease;
  &:hover {
    transform: translateY(-2px);
  }
`;

export const BaseStyle = ({ hoverEffect = false }: IconProps) => css`
  width: 24px;
  height: 24px;
  color: var(--text-muted-color);
  `${hoverEffect ? HoverStyle : ''}`
`;

export const IconBase = styled.svg<IconProps>`
  ${BaseStyle}
`;
```

`iconBase.ts` inneh√•ller i den h√§r iterationen all grundl√§ggande styling som alla ikoner anv√§nde sig av. Ett gemensamt interface f√∂r ikonprops skapades ocks√• i och med `IconProps`. En hover-effekt lades √§ven till.

Ikoner i sin tur byggdes ovanp√• `iconBase.ts` p√• f√∂ljande vis:

```tsx:src/components/ui/icons/iconLightMode.tsx
import { Sunrise } from '@styled-icons/feather';
import styled from 'styled-components';
import { BaseStyle, IconProps } from './iconBase';

export const IconLightMode = styled(Sunrise)<IconProps>`
  ${BaseStyle}
`;

IconLightMode.displayName = 'IconLightMode';
```

**Perfekt!** Nu var duplicerad kod borttagen och endast en k√§lla till ikonstyling existerade. Nu m√•ste v√§l allt vara frid och fr√∂jd?

## Skapa komponenter med (ett) tydligt ansvar üôã‚Äç‚ôÇÔ∏è

Det var √§nd√• n√•got som inte k√§ndes helt r√§tt. Alla ikoner som bygger vidare p√• `iconBase.ts` ansvarar inte _bara_ f√∂r vilken svg-ikon de importerar och anv√§nder sig av. De ansvarar _√§ven_ f√∂r att se till att ikonerna applicerar den grundl√§ggande stylingen fr√•n `iconBase.ts`.

Vore det inte b√§ttre om alla olika ikonkomponenter ist√§llet _bara_ ansvarade f√∂r vilken ikon fr√•n styled-icons de importerade? Samt skickade vidare allt annat ansvar s√•som _props_ och _styling_ till `iconBase.ts`?

S√• klart det vore! I iteration tre och nuvarande version (i skrivande stund) separerades det ansvaret genom en mindre refaktorering av `iconBase.ts`:

```tsx{4,14,15,16}:src/components/ui/icons/iconBase.ts
import styled, { css } from 'styled-components';
import { StyledIconProps, StyledIcon } from '@styled-icons/styled-icon';

export interface IconProps extends StyledIconProps {
  hoverEffect?: boolean;
}

const HoverStyle = css`
  transition: all 0.2s ease;
  &:hover {
    transform: translateY(-2px);
  }
`;

const defaultSize = css`
  height: 24px;
  width: 24px;
`;

export const BaseStyle = ({ hoverEffect = false, size }: IconProps) => css`
  color: var(--text-muted-color);
  `${!size && defaultSize}`;
  `${hoverEffect && HoverStyle}`;
`;

export const IconBase = (icon: StyledIcon): StyledIcon => styled(icon)<IconProps>`
  ${BaseStyle}
`;

```

> `${!size && defaultSize}` anv√§nds f√∂r att styled-icons har en prop, size, som s√§tter en storlek p√• ikonerna. Om ingen storlek s√§tts s√• kickar defaultSize stylingen ig√•ng.

N√•gra sm√• √§ndringar (som √§r markerade i kodsnutten ovan) visar p√• skillnaderna:

- Interfacet `IconProps` bygger nu vidare p√• interfacet `StyledIconProps` - som √§r det interface som alla styled-icons har. Det inneb√§r att kopplingen mellan p√•byggd funktionalitet i form av props tydligare kopplas ihop med betinflig funktionalitet och props fr√•n _styled-icons_ ikoner.
- `IconBase` var tidigare bara en `styled.svg` som hade lite grundl√§ggande styling i och med `BaseStyle`. Nu √§r det en funktion som tar in en `icon` av typen `StyledIcon` och returnerar en styled-icon som har default styling och som har korrekt interface f√∂r props.

Ikonkomponenter refaktorerades i iteration tre att se ut p√• f√∂ljande vis:

```tsx{4}:src/components/ui/icons/iconLightMode.tsx
import { Sunrise } from '@styled-icons/feather';
import { IconBase, IconProps } from './iconBase';

const Icon = IconBase(Sunrise);

export const IconLightMode: React.FC<IconProps> = (props) => {
  return <Icon {...props} />;
};

IconLightMode.displayName = 'IconLightMode';
```

Den nya strukturen inneb√§r att varje ikonkomponent nu egentligen bara har **ett enda ansvar** - att best√§mma vilken ikon de ska importera och representera i och med `const Icon = IconBase(Sunrise);`.

Ikonkomponenterna skickar glatt vidare alla props med `<Icon {...props} />;`. All styling och √∂vrig logik hanteras i baskomponenten ist√§llet i och med att ikonkomponenterna bara skickar visare sina `props`.

## Summering

S√• l√§nge man f√∂rs√∂ker t√§nka p√• att separera ansvar och har √•teranv√§ndbarhet i √•tanke kan man skapa r√§tt s√• flexibla l√∂sningar f√∂r ui-komponenter, med hj√§lp av styled components.

Att l√•ta en komponent p√• en _l√§gre_ niv√• ansvara f√∂r gemensam logik och generella stilregler g√∂r att man kan skapa komponenter _ovanp√•_ - som inte beh√∂ver bry sig, eller ens veta om de gemensamma detaljerna.

Det √§r inte hela v√§rlden om det inte blir 100% r√§tt f√∂rsta g√•ngen eller om koden man skriver i en f√∂rsta implementation √§r 100% fri fr√•n duplicering.
Det kan dessutom vara sv√•rt att p√• f√∂rhand se hela behovsbilden och det √§r l√§tt att b√∂rja optimera f√∂r fel saker om man f√∂rs√∂ker ta h√∂jd och t√§cka in f√∂r mycket - f√∂r tidigt.

√ñver tid n√§r behoven √§ndras och man v√§xer ur befintlig implementation √§r det bara att iterera och refaktorera i mindre steg tills man uppn√•r ett b√§ttre l√§ge och t√§cker in nyuppt√§ckta behov.
