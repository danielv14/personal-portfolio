---
title: Schema Validation av SearchParams med Zod
summary: Anv칛nd Zod som 칛r ett "TypeScript-first schema validation" paket f칬r att validera och transformera datastrukturer
date: 2023-01-20
---

I en [Next.js applikation](https://pic-palette.vercel.app/) som jag har byggt anv칛nds `URL.searchparams` f칬r att hantera s칬kstr칛ngar och paginering. URL-strukturen f칬r en s칬ksida p친 sajten ser ut s친h칛r: `/search?page=2&query=cats&perPage=12`.

Just strukturen f칬r paginering, allts친 `?page=2&perPage=12` 칛r parameterar som 친teranv칛nds p친 ett annat st칛llen p친 sajten. Den andra URL:en ser ut s친h칛r: `/list?type=popular&page=2&perPage=12`

## Manuell parsnig av searchparams

I ett f칬rsta stadie s친 l칛ste jag av och parsade ut v칛rden ur `searchparams` manuellt. Ungef칛r s친h칛r:

```ts showLineNumbers
const options = {
  query: searchParams?.query ?? '',
  perPage: parseInt(searchParams?.perPage ?? '12'),
  page: parseInt(searchParams?.page ?? '0'),
};

// Call API to fetch paginated stuff by the query
const data = await API.getByQuery(options);
```

Observera att null-checkar beh칬ver g칬ras med `searchParams?.[VALUE]` samt att fallback-v칛rden anv칛nds.
P친 rad 3 och 4 g칬rs 칛ven en `parseInt()` f칬r att konvertera till integers. Detta eftersom att alla searchParams hanteras som str칛ngar och det API jag anropar f칬rv칛ntar sig att `page` och `perPage` 칛r siffor (vilket 칛r rimligt 칛nd친).

Det var s칬ksidan det. Sen var det ju den andra sidan, `/list`. Den sidan byggde upp ett snarlikt `options` objekt:

```ts showLineNumbers
const options = {
  type: searchParams?.type || ListType.Latest, // Enum for 'latest' or 'popular'
  perPage: parseInt(searchParams?.perPage ?? '12'),
  page: parseInt(searchParams?.page ?? '0'),
};

// Call API to fetch paginated stuff by the list type
const data = await API.getByListType(options);
```

Tv친 stycken sidor (eller Next.js routes om man s친 vill) hade lite duplicerad logik allts친. F칬rvisso hade man kunnat extrahera ut logiken som manglar `searchParams` till en gemensam funktion men jag valde ist칛llet att testa p친 `zod`.

## General Zod has entered the game

Det h칛r 칛r ingen bloggpost om _vad_ Zod 칛r, utan mer hur man kan anv칛nda det och hur det gick till n칛r jag testade att anv칛nda det. Men kortfattat (h칛mtat fr친n [Zods dokumentation](https://zod.dev/)) s친 beskrivs Zod s친h칛r: <FunText>TypeScript-first schema validation with static type inference.</FunText>

Kortfattat handlar det bland annat om att s칛kerst칛lla exempelvis ett objekts struktur med hj칛lp av ett definierat `schema` som man anv칛nder f칬r att parsa data. `static type inference` biten handlar om att man utifr친n ett Zod Schema kan extrahera typings (types och interfaces m.m) f칬r hur den f칬rv칛ntade datastrukturen ser ut.

Men hur anv칛nder man d친 ett s친nt d칛r `schema` f칬r att parsa searchParams? I mitt fall med min Next.js applikation s친 gick refaktoreringen till Zod i tv친 steg:

1. Skapa scheman som g친r att anv칛nda f칬r att parsa searchParams.
2. Parsa searchParams och skicka som input till API:et.

### Skapa scheman

Jag b칬rjade med att skapa ett schema f칬r `/search` sidan, d칛r `query`, `page` och `perPage` var aktuella searchParams:

```ts:schemas/QuerySchema.ts showLineNumbers
import { z } from 'zod';

export const QuerySchema = z.object({
  page: z
    .string()
    .default("0")
    .transform((val) => parseInt(val)),
  perPage: z
    .string()
    .default(`${12}`)
    .transform((val) => parseInt(val)),
  query: z.string().default(""),
})

export type QueryOptions = z.infer<typeof QuerySchema>;

```

`QuerySchema` 칛r allts친 sj칛lva schemat som kommer anv칛ndas f칬r att parsa ut v칛rden ut searchParams. Typen `QueryOptions` 칛r en type som utifr친n ovanst친ende schema skulle se ut s친h칛r: `{query: string; perPage: number; page: number;}`. Typen blir automatiskt infered utifr친n schemat.

Observera att schemat tar h칬jd f칬r att transformera `page` och `perPage` till siffror och hanterar defaultv칛rden.

Schemat f칬r `/list` sidan blir v칛ldigt snarlik:

```ts:schemas/ListSchema.ts showLineNumbers
import { z } from 'zod';

export const ListSchema = z.object({
  page: z
    .string()
    .default("0")
    .transform((val) => parseInt(val)),
  perPage: z
    .string()
    .default(`${12}`)
    .transform((val) => parseInt(val)),
  type: z.nativeEnum(OrderBy).default(OrderBy.POPULAR)
})

export type ListOptions = z.infer<typeof ListSchema>;

```

Skillnaden h칛r 칛r att `type` 칛r en `z.nativeEnum()` vilket 칛r ett schysst s칛tt att anv칛nda enums eller types i zod schemas.

### F친 bort duplicerad paginering

N칛r jag satte upp mina tv친 schemas st칬rde jag mig fortfarande p친 att `page` och `perPage` var duplicerade i b칛gge schemas. Det 칛r ju s친klart inte s친 trevligt.

Zod har ett smidigt s칛tt att hantera den h칛r sortens problem. Scheman har st칬d f칬r en `.merge()` funktion, d칛r man helt enkelt sl친r ihop flertalet schemas till ett.

Det jag d친 kunde g칬ra var att s칛tta upp ett separat schema f칬r paginering och sen sl친 ihop det schemat med `QuerySchema` och `ListSchema`:

```ts:schemas/PaginationSchema.ts showLineNumbers
import { z } from 'zod';

export const PaginationSchema = z.object({
  page: z
    .string()
    .default("0")
    .transform((val) => parseInt(val)),
  perPage: z
    .string()
    .default(`${12}`)
    .transform((val) => parseInt(val)),
})

```

Sen i exempelvis `schemas/ListSchema.ts` s친g det ut s친h칛r:

```ts:schemas/ListSchema.ts showLineNumbers {8}
import { z } from 'zod';
import { PaginationSchema } from './PaginationSchema';

const ListSchemaBase = z.object({
  type: z.nativeEnum(OrderBy).default(OrderBy.POPULAR)
})

export const ListSchema = ImageListBaseSchema.merge(PaginationSchema);
export type ListOptions = z.infer<typeof ListSchema>;
```

Nu var inte logiken kring pagineringen duplicerad utan scheman mergades ist칛llet ihop 游녨. `ListOption` typen 칛r 칛ven fortfarande intakt j칛mf칬rt med tidigare och inneh친ller `page` och `perPage` som siffor.

### Parsa searchParams

N칛r man v칛l har sina scheman kan man applicera dem p친 datastrukturer med tv친 funktioner, `.parse()` och `safeParse()`. S친 h칛r s칛ger dokumentationen om de tv친 alternativen:

1. `parse()` - _Given any Zod schema, you can call its `.parse` method to check data is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown._
2. `safeParse()` - _If you don't want Zod to throw errors when validation fails, use `.safeParse`. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems._

I mitt fall, d친 min Next.js applikation bara 칛r ett enkelt hoppyprojekt valde jag `parse` och struntade i felhanteringen. I en riktig produktionsmilj칬 vill man s친klart se 칬ver valet h칛r och implementera ordentlig felhanterning.

Anyhow... S친 h칛r s친g nu en route ut:

```ts showLineNumbers
import { QuerySchema } from '../schemas/QuerySchema';

const options = QuerySchema.parse(searchParams);

// Call API to fetch paginated stuff by the query
const data = await API.getByQuery(options);
```

Aningen mer <FunText>cleant</FunText> 칛n tidigare kan jag tycka 游끥

Men kunde jag anv칛nda det typer som extraherades med `z.infer<T>` p친 n친got s칛tt? Jod친, dom typerna anv칛ndes i `API` wrappern f칬r att typa input till `getByQuery(options: QueryOptions)` och `getByListType(options: ListOptions)` funktionerna. F칬rdelarna med det 칛r:

- Kopplingen mellan schemat och hur datan anv칛nds blir tydligare.
- Man slipper h친lla separat typings f칬r parametrar till API funktionerna i synk med 칬vrig kod d친 det bara finns en sanning (schemat).

### Summa kardemumma

Zod kan kanske tyckas lite overkill f칬r en s친n h칛r enkel grej men jag kan 칛nd친 tycka att det var v칛rt att refaktorera till att anv칛nda Zod i hobbyprojektet. Detta f칬r att jag tyckte det innebar en del f칬rdelar:

1. B칛ttre DX: Den type inference som Zod kommer med 칛r v칛ldigt smidigt.
2. B칛ttre DX: Ett robust verktyg f칬r att validera och transformera data.
3. Alltid kul att prova n친got nytt!
4. Tyckte inte det innebar speicellt 칬kad komplexitet i applikationen.

Nu har jag bara tagit upp ett anv칛ndningsomr친de f칬r Zod och ett r칛tt litet s친dant. Det finns ju v칛ldigt mycket mer man kan anv칛nd Zod till s친som exempelvis middlewares till en express-server f칬r att validera request bodies, mappa databasobjekt till DTO:er, validering av formul칛rdata och s칛kert mycket, mycket mer.

Men i framtiden om jag beh칬ver manipulera searchParams eller kanske skapa middlewares i express f칬r att validera anv칛ndardata kommer nog `yarn add zod` inte vara l친ngt bort.
